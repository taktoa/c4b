# 1 "Parse.mll"
  (* Parsing and printing of while programs *)

open Grammar
exception LexError of char
exception ParseError of string

let kw =
  [ "while", WHILE; "loop", LOOP; "assert", ASSERT; "if", IF
  ; "else", ELSE; "break", BREAK; "func", FUNC; "local", LOCAL
  ; "return", RETURN
  ]


# 16 "Parse.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\238\255\239\255\240\255\241\255\242\255\243\255\244\255\
    \245\255\246\255\002\000\003\000\058\000\133\000\253\255\001\000\
    \255\255\250\255\249\255";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\008\000\007\000\004\000\003\000\255\255\001\000\
    \255\255\255\255\255\255";
  Lexing.lex_default = 
   "\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\255\255\255\255\255\255\000\000\015\000\
    \000\000\000\000\000\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\016\000\014\000\255\255\000\000\016\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \016\000\000\000\000\000\015\000\000\000\000\000\000\000\000\000\
    \005\000\004\000\008\000\007\000\002\000\006\000\000\000\000\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\000\000\003\000\011\000\009\000\010\000\018\000\
    \017\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\000\000\000\000\000\000\000\000\012\000\
    \000\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\000\000\000\000\000\000\
    \000\000\012\000\000\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\015\000\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\000\000\000\000\010\000\
    \011\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\255\255\255\255\255\255\255\255\000\000\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\255\255\255\255\255\255\
    \255\255\012\000\255\255\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\015\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255";
  Lexing.lex_base_code = 
   "";
  Lexing.lex_backtrk_code = 
   "";
  Lexing.lex_default_code = 
   "";
  Lexing.lex_trans_code = 
   "";
  Lexing.lex_check_code = 
   "";
  Lexing.lex_code = 
   "";
}

let rec tok lexbuf =
    __ocaml_lex_tok_rec lexbuf 0
and __ocaml_lex_tok_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 16 "Parse.mll"
                                ( tok lexbuf )
# 151 "Parse.ml"

  | 1 ->
# 17 "Parse.mll"
                                ( tok lexbuf )
# 156 "Parse.ml"

  | 2 ->
# 18 "Parse.mll"
                                ( Lexing.new_line lexbuf; tok lexbuf )
# 161 "Parse.ml"

  | 3 ->
let
# 19 "Parse.mll"
                  s
# 167 "Parse.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 19 "Parse.mll"
                                ( NUM (int_of_string s) )
# 171 "Parse.ml"

  | 4 ->
let
# 20 "Parse.mll"
                              s
# 177 "Parse.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 20 "Parse.mll"
                                ( try List.assoc s kw with _ -> IDNT s )
# 181 "Parse.ml"

  | 5 ->
# 21 "Parse.mll"
                                ( LE )
# 186 "Parse.ml"

  | 6 ->
# 22 "Parse.mll"
                                ( GE )
# 191 "Parse.ml"

  | 7 ->
# 23 "Parse.mll"
                                ( LT )
# 196 "Parse.ml"

  | 8 ->
# 24 "Parse.mll"
                                ( GT )
# 201 "Parse.ml"

  | 9 ->
# 25 "Parse.mll"
                                ( EQ )
# 206 "Parse.ml"

  | 10 ->
# 26 "Parse.mll"
                                ( STAR )
# 211 "Parse.ml"

  | 11 ->
# 27 "Parse.mll"
                                ( PLUS )
# 216 "Parse.ml"

  | 12 ->
# 28 "Parse.mll"
                                ( MINUS )
# 221 "Parse.ml"

  | 13 ->
# 29 "Parse.mll"
                                ( LPAREN )
# 226 "Parse.ml"

  | 14 ->
# 30 "Parse.mll"
                                ( RPAREN )
# 231 "Parse.ml"

  | 15 ->
# 31 "Parse.mll"
                                ( SEMI )
# 236 "Parse.ml"

  | 16 ->
# 32 "Parse.mll"
                                ( COMMA )
# 241 "Parse.ml"

  | 17 ->
# 33 "Parse.mll"
                                ( EOF )
# 246 "Parse.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; 
      __ocaml_lex_tok_rec lexbuf __ocaml_lex_state

;;

# 35 "Parse.mll"
 

open Ast

let pp_var oc = function
  | VNum n -> Printf.fprintf oc "%d" n
  | VId x -> Printf.fprintf oc "%s" x

let pp_file_hooks pre post (fl, prog) =
  let open Printf in

  let rec pp_list p oc = function
    | [x] -> fprintf oc "%a" p x
    | x :: xs -> fprintf oc "%a, %a" p x (pp_list p) xs
    | [] -> () in

  let rec lsum prns = function
    | LAdd (l1, l2) ->
      if prns then printf "(";
      lsum false l1; printf " + "; lsum false l2;
      if prns then printf ")"
    | LSub (l1, l2) ->
      if prns then printf "(";
      lsum false l1; printf " - "; lsum true l2;
      if prns then printf ")"
    | LMult (k, l) ->
      printf "%d * " k;
      lsum true l
    | LVar v ->
      printf "%a" pp_var v in

  let cond = function
    | CTest (l1, cmp, l2) ->
      lsum false l1;
      printf " %s " (
        match cmp with
        | CLe -> "<="
        | CGe -> ">="
        | CLt -> "<"
        | CGt -> ">"
      );
      lsum false l2
    | CNonDet -> printf "*" in

  let rec idnt i =
    if i <> 0 then
      begin print_string " "; idnt (i - 1) end in

  let delta = 2 in

  let rec f lvl prns = function
    | PTick (0, _) -> printf "()"
    | PTick (n, _) -> printf "(%d)" n
    | PBreak _ -> printf "break"
    | PAssert (c, _) -> printf "assert "; cond c
    | PReturn (v, _) -> printf "return %a" pp_var v
    | PCall (xo, f, args, _) ->
      begin match xo with
      | Some x -> printf "%s = " x
      | _ -> ()
      end; printf "%s(%a)" f (pp_list pp_var) args
    | PSet (id, Some v, _) -> printf "%s = %a" id pp_var v
    | PSet (id, None, _) -> printf "%s = *" id
    | PInc (id, o, v, _) ->
      let op = match o with OPlus -> "+" | OMinus -> "-" in
      printf "%s %s= %a" id op pp_var v
    | PSeq (p1,  p2, _) ->
      let lvl' = if prns
        then (idnt lvl; printf "(\n"; lvl + delta)
        else lvl in
      g lvl' true p1; printf ";\n";
      g lvl' false p2;
      if prns then (printf "\n"; idnt lvl; printf ")")
    | PIf (c, p1, p2, _) ->
      printf "if "; cond c; printf "\n";
      g (lvl + delta) true p1;
      begin match p2 with
      | PTick (0, _) -> ()
      | _ ->
        printf "\n"; idnt lvl; printf "else\n";
        g (lvl + delta) true p2
      end
    | PLoop (p, _) ->
      printf "loop\n";
      g (lvl + delta) true p


  and g lvl prns p =
    match p with
    | PSeq (_, _, _) -> f lvl prns p
    | _ ->
      if prns then pre (prog_data p);
      idnt lvl; f lvl prns p;
      if not prns then post (prog_data p)
  in

  let pf {fname; fargs; flocs; fbody} =
    printf "func %s(%a)" fname (pp_list output_string) fargs;
    if flocs <> [] then
      printf " local (%a)\n" (pp_list output_string) flocs
    else
      printf "\n";
    g delta true fbody;
    printf ";\n"
  in

  begin
    List.iter pf fl;
    if fl <> [] then printf "\n";
    g 0 false prog;
    printf "\n";
  end

let pp_file x = let f _ = () in pp_file_hooks f f x
let pp_prog p = pp_file ([], p)

let pa_file ic =
  let open Lexing in
  let lexbuf = from_channel ic in
  try Grammar.program tok lexbuf with
  | Parsing.Parse_error ->
    let e =
      Printf.sprintf "line %d, character %d"
        lexbuf.Lexing.lex_start_p.pos_lnum
        (lexbuf.lex_start_p.pos_cnum -
         lexbuf.lex_start_p.pos_bol + 1) in
    raise (ParseError e)

let _ =
  match try Sys.argv.(1) with _ -> "" with
  | "-tparse" ->
    let p = pa_file stdin in
    pp_file p
  | _ -> ()


# 390 "Parse.ml"
